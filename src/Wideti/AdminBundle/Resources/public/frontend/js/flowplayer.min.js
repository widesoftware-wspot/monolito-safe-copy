(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined'
    ? (module.exports = factory())
    : typeof define === 'function' && define.amd
    ? define(factory)
    : (global.flowplayer = factory());
})(this, function () {
  'use strict';
  //
  // cache a reference to slice
  var $SLICE = [].slice;
  function noop() {}
  function safe(fn, ctx) {
    return function caught() {
      try {
        return fn.apply(ctx, arguments);
      } catch (err) {
        return null;
      }
    };
  }
  function extend(to, from) {
    for (var key in from) {
      to[key] = from[key];
    }
    return to;
  }
  function assign() {
    var args = $SLICE.call(arguments),
      target = args.shift();
    return args.reduce(extend, target);
  }
  /**
   * converts a string Object path to an Array<string>
   * unless it already conforms to Array<string>
   */
  function make_path(path) {
    return Array.isArray(path) ? path.slice(0) : path.split('.');
  }
  /**
   * safely access deeply nested properties
   */
  function lens(obj, path, _default) {
    path = make_path(path);
    // walk the object
    while (path.length) {
      // bail early if the path is invalid
      if (typeof obj === 'undefined') return _default;
      obj = obj[path.shift()];
    }
    return typeof obj === 'undefined' ? _default : obj;
  }
  /**
   * safely puts a value to a deeply nested path,
   * is a noop if an intermediate property in the path does
   * not exist
   */
  function put(obj, path, val) {
    path = make_path(path);
    var dest = path.pop();
    var ref = lens(obj, path);
    if (ref) ref[dest] = val;
    return obj;
  }
  function get(url, resolve, reject) {
    var req = new XMLHttpRequest();
    req.open('GET', url, true);
    req.onreadystatechange = function _get() {
      var status = req.status;
      if (status >= 400 && reject) {
        reject(status);
      }
      if (status != 200 || req.readyState != 4) return;
      resolve(req.responseText);
    };
    req.send();
  }
  function zero_pad(val) {
    val = parseInt(val, 10);
    return val >= 10 ? val : '0' + val;
  }
  function prettyTime(sec) {
    if (isNaN(sec)) return '';
    var head_symbol = sec < 0 ? '-' : '';
    sec = Math.abs(sec);
    var h = Math.floor(sec / 3600),
      min = Math.floor(sec / 60);
    sec = sec - min * 60;
    if (h >= 1) {
      min -= h * 60;
      return head_symbol + h + ':' + zero_pad(min) + ':' + zero_pad(sec);
    }
    return head_symbol + zero_pad(min) + ':' + zero_pad(sec);
  }
  function toArray(arr_like) {
    return $SLICE.call(arr_like);
  }
  /**
   * a functional reference to a value
   *
   * @param      {any}  val     The value
   * @return     {Function}     The functional reference
   */
  function box(val) {
    var boxed = {
      val: val,
    };
    return function ref(update) {
      if (update !== undefined) {
        boxed.val = update;
      }
      return boxed.val;
    };
  }
  function as_bool(val) {
    if (typeof val != 'string') return val;
    if (!isNaN(val)) return Number(val);
    if (val == 'false') return false;
    if (val == 'true') return true;
    return val;
  }
  var util = Object.freeze({
    noop: noop,
    safe: safe,
    extend: extend,
    assign: assign,
    make_path: make_path,
    lens: lens,
    put: put,
    get: get,
    zero_pad: zero_pad,
    prettyTime: prettyTime,
    toArray: toArray,
    box: box,
    as_bool: as_bool,
  });
  function createEvent(name) {
    // https://developer.mozilla.org/en-US/docs/Web/API/Event/Event
    // this is not supported in IE, but the current way is deprecated
    /*if (typeof Event == "function") {
        return new Event(name, {
            bubbles    : false
          , cancelable : false
        })
      }*/
    // this is slated for removal from several vendors
    // https://developer.mozilla.org/en-US/docs/Web/API/Event/initEvent
    var event = document.createEvent('Event');
    // https://github.com/flowplayer/flowplayer-native/issues/301
    // allow internal events to have preventDefault() called
    event.initEvent(name, false, true);
    return event;
  }
  function observable(el) {
    el.emit = function emit(name, data) {
      var event = createEvent(name);
      if (data)
        extend(event, {
          data: data || {},
        });
      el.dispatchEvent(event);
      return el;
    };
    el.on = function on(events, fn) {
      if (typeof events == 'string') {
        events = events.split(' ');
      }
      events.forEach(function (name) {
        el.addEventListener(name, fn);
      });
      return el;
    };
    el.off = function off(event, fn) {
      el.removeEventListener(event, fn);
      return el;
    };
    // conform to Node.js emitter api for once
    el.one = el.once = function one(event, fn) {
      function on(e) {
        el.off(event, on);
        fn(e);
      }
      return el.on(event, on);
    };
    return el;
  }
  //
  /*
    Shared DOM operations
  */
  var EMPTY = '';
  var SPACE = ' ';
  var $isArray = Array.isArray;
  var $window = typeof window !== 'undefined' && observable(window);
  var $document = typeof document !== 'undefined' && observable(document);
  var INLINE = ['span', 'a', 'em', 'p', 'i'];
  var TAGS = INLINE.concat([
    'div',
    'strong',
    'video',
    'img', // block elements
    'ol',
    'ul',
    'li',
    'script', // invisible elements
  ]);
  /**
   * creates an HTMLElement and wraps it with miniquery extensions
   */
  function el(name, opts, children) {
    var tag = createMQElement(document.createElement(name));
    // if binary function call with el(<TagName>, Array<Children>)
    if ($isArray(opts)) {
      children = opts;
      opts = false;
    }
    // ensure children is always an Array
    if (!$isArray(children)) children = [children];
    // prune falsy values for more terser ui building
    // and append to parent
    tag.append(
      children.filter(function (child) {
        return child;
      }),
    );
    // short-circuit when opts are not present
    if ('object' !== typeof opts) return tag;
    // go through DOM property assignment
    for (var attr in opts) {
      // innerText & ilk which actually exist on an HTMLElement constructor
      if (attr in tag) tag[attr] = opts[attr];
      // other attributes that are not on the constructor
      else tag.setAttribute(attr, opts[attr]);
    }
    // always return the tag ref
    return tag;
  }
  function methods(el) {
    var tag = el.tagName;
    el.find = function (query) {
      var found = el.querySelector(query);
      if (found) return createMQElement(found);
      return found;
    };
    el.html = function (str) {
      el.innerHTML = str;
      return el;
    };
    el.empty = function () {
      el.innerHTML = EMPTY;
      return el;
    };
    el.offset = function () {
      var offset = {
          top: 0,
          left: 0,
        },
        node = el;
      do {
        offset.left += node.offsetLeft || 0;
        offset.top += node.offsetTop || 0;
        /*eslint no-cond-assign: 0*/
      } while ((node = node.offsetParent));
      return offset;
    };
    el.innerWidth = function () {
      var style = getComputedStyle(el);
      return (
        el.clientWidth -
        parseFloat(style.paddingLeft) -
        parseFloat(style.paddingRight)
      );
    };
    var insert = (el.insert = function insert(position, child) {
      if ($isArray(child)) {
        return child.map(function (node) {
          return el.insert(position, node);
        })[0];
      }
      typeof child == 'string'
        ? (child = el.insertAdjacentHTML(position, child))
        : el.appendChild(child);
      return createMQElement(child);
    });
    el.append = insert.bind(el, 'beforeend');
    el.prepend = insert.bind(el, 'afterbegin');
    el.css = function (key, val) {
      if (typeof key == 'object') {
        for (var name in key) {
          el.css(name, key[name]);
        }
        return el;
      }
      if (val === undefined) return getComputedStyle(el)[key];
      if (1 * val) val += 'px';
      el.style[key] = val;
      return el;
    };
    el.show = function () {
      // "initial" not working on IE
      return el.css({
        display: ~INLINE.indexOf(tag) ? 'inline' : 'block',
      });
    };
    el.hide = function () {
      return el.css({
        display: 'none',
      });
    };
    el.remove = function () {
      var p = el.parentNode;
      p && p.removeChild(el);
    };
    el.attr = function (name, value) {
      if (value == undefined) return el.getAttribute(name);
      el.setAttribute(name, value);
      return el;
    };
    el.txt = function (text) {
      el.textContent = text;
      return el;
    };
    el.fp = function (name) {
      return el.addClass('fp-' + name);
    };
    // addClass
    el.addClass = function (names) {
      names.split(SPACE).forEach(function (name) {
        if (!el.hasClass(name))
          el.className += (el.className ? SPACE : EMPTY) + name;
      });
      return el;
    };
    // removeClass
    el.removeClass = function (names) {
      names = names.split(SPACE);
      var current_classes = el.className.split(SPACE);
      el.className = current_classes
        .filter(function (klass) {
          return !~names.indexOf(klass);
        })
        .join(' ');
      return el;
    };
    // toggleClass
    el.toggleClass = function (names, flag) {
      if (flag === undefined) flag = !el.hasClass(names);
      return flag ? el.addClass(names) : el.removeClass(names);
    };
    el.findAll = function (query) {
      return toArray(el.querySelectorAll(query));
    };
    // hasClass
    el.hasClass = function (name) {
      return ~el.className.split(SPACE).indexOf(name);
    };
    return el;
  }
  /**
   * extends an MQElement with the entirety of the MQ api
   */
  function createMQElement(el) {
    if (typeof el === 'undefined') return el;
    if (el && el.on && typeof el.on == 'function') return el;
    return methods(observable(el));
  }
  /**
   * main miniquery interface, which allows
   */
  function mq(query, root) {
    if (typeof query == 'string' && query[0] == '<')
      return el(query.slice(1, -1), root);
    if (typeof query !== 'string') return createMQElement(query);
    var node =
      (root instanceof HTMLElement && root.querySelector('.fp-' + query)) ||
      document.querySelector(query);
    return node ? createMQElement(node) : void 0;
  }
  mq.window = $window;
  mq.document = $document;
  mq.el = el;
  /**
   * this generates and we want the parser to immediately
   */
  TAGS.forEach(function (tag) {
    mq[tag] = function (opts, children) {
      // div("classname", Array(children))
      if (typeof opts == 'string')
        opts = {
          class: opts,
        };
      return el(tag, opts, children);
    };
  });
  var instances = [];
  function playing() {
    return instances.filter(function (video) {
      return !video.paused;
    });
  }
  var Players = Object.freeze({
    instances: instances,
    playing: playing,
  });
  /**
   * all events used by Flowplayer
   */
  var Events = {
    // when a new player is inserted into the HTML
    MOUNT: 'mount',
    // native events that flowplayer uses
    ERROR: 'error',
    CONTEXT_MENU: 'contextmenu',
    CLICK: 'click',
    DBL_CLICK: 'dblclick',
    KEYUP: 'keyup',
    KEYDOWN: 'keydown',
    LOAD: 'load',
    MOUSE_ENTER: 'mouseenter',
    MOUSE_LEAVE: 'mouseleave',
    MOUSE_UP: 'mouseup',
    MOUSE_DOWN: 'mousedown',
    MOUSE_MOVE: 'mousemove',
    RESIZE: 'resize',
    SCROLL: 'scroll',
    FULLSCREEN_ENTER: 'fullscreenenter',
    FULLSCREEN_EXIT: 'fullscreenexit',
    FULLSCREEN_CHANGE: 'fullscreenchange',
    // general video events flowplayer uses internally
    // https://developer.mozilla.org/en-US/docs/Web/Guide/Events/Media_events
    METADATA: 'loadedmetadata',
    DATA: 'loadeddata',
    PROGRESS: 'progress',
    TIME_UPDATE: 'timeupdate',
    LOAD_START: 'loadstart',
    VOLUME_CHANGE: 'volumechange',
    PAUSE: 'pause',
    PLAYING: 'playing',
    WAITING: 'waiting',
    CAN_PLAY: 'canplay',
    ENDED: 'ended',
    SEEKED: 'seeked',
    SEEKING: 'seeking',
    DURATION_CHANGE: 'durationchange',
    // cuepoints parsing is asynchronous
    // you cannot rely on them existing until
    // this event is emitted
    CUEPOINTS: 'cuepoints',
    // when a cuepoint is active
    CUEPOINT_START: 'cuepointstart',
    // when a cuepoint becomes inactive
    CUEPOINT_END: 'cuepointend',
    // when a player enters the viewpoint
    VIEW_ENTER: 'viewenter',
    // when a player leaves the viewport
    VIEW_LEAVE: 'viewleave',
    // emitted when a valid source is found prior to mounting
    SOURCE: 'src',
    // emitted when an Error recovery is attempted
    RECOVER: 'recover',
    // emitted when it is safe to clean up a fp instance
    REAP: 'reap',
    // emitted whenever config is changed
    CONFIG: 'config',
    // emitted whenever a list of qualities has been made available
    // when index 0 is the highest quality and index 0+N is the lowest
    QUALITIES: 'qualities',
    // allows plugins to listen for forced quality changes
    // it should emit the index of the quality to set
    // -1 is a special idx saying to use ABR if the plugin
    // exposes an ABR implementation
    SET_QUALITY: 'quality:set',
    // error that is fatal in a sense where nothing can be done and
    // player should be destroyed
    NON_RECOVERABLE_ERROR: 'error:fatal',
  };
  /**
   * all states a player can be in
   */
  var states = {
    FULLSCREEN: 'is-fullscreen',
    PLAYING: 'is-playing',
    PAUSED: 'is-paused',
    MUTED: 'is-muted',
    LOADED: 'is-loaded',
    LOADING: 'is-loading',
    STARTING: 'is-starting',
    SEEKING: 'is-seeking',
    GRABBING: 'is-grabbing',
    DISABLED: 'is-disabled',
    SMALL: 'is-small',
    TINY: 'is-tiny',
    RTL: 'is-rtl',
    ENDED: 'is-ended',
    LIVE: 'is-live',
    ERRORED: 'is-error',
    WAITING: 'is-waiting',
    AUTOPLAY: 'is-autoplay',
    SEAMLESS: 'is-seamless',
    NO_AUTOPLAY: 'no-autoplay',
    TOGGLING: 'is-toggling',
    LIVE_SEEKED: 'is-live-seeked',
    NO_DVR: 'no-timeline',
  };
  function parse_ver(ua, pattern) {
    try {
      var match = pattern.exec(ua)[1];
      return parseFloat(match, 10);
    } catch (err) {
      console.error(err);
      return 0;
    }
  }
  function support() {
    var in_browser =
      typeof document !== 'undefined' && typeof window !== 'undefined';
    var UA = in_browser ? navigator.userAgent : '',
      IS_IPHONE =
        /iP(hone|od)/i.test(UA) && !/iPad/.test(UA) && !/IEMobile/i.test(UA),
      IS_ANDROID = /Android/.test(UA) && !/Firefox/.test(UA),
      IS_IE_MOBILE = /IEMobile/.test(UA),
      WIN_PHONE_VER = IS_IE_MOBILE
        ? parse_ver(UA, /Windows Phone (\d+\.\d+)/)
        : 0,
      IE_MOBILE_VER = IS_IE_MOBILE ? parse_ver(UA, /IEMobile\/(\d+\.\d+)/) : 0;
    var IE_VERSION = (function () {
      if (!in_browser) return false;
      if (document.documentMode) return document.documentMode;
      for (var i = 9; i > 3; i--) {
        var div = document.createElement('div');
        div.innerHTML = '<!--[if IE ' + i + ']><span></span><![endif]-->';
        if (div.getElementsByTagName('span').length) return i;
      }
      return false;
    })();
    var self = {
      controls:
        !IS_IPHONE &&
        (!IS_IE_MOBILE || (WIN_PHONE_VER >= 8.1 && IE_MOBILE_VER >= 11)),
      video: function (type) {
        return in_browser && document.createElement('video').canPlayType(type);
      },
      lang:
        in_browser &&
        (window.navigator.userLanguage || window.navigator.language),
      android: IS_ANDROID,
      iphone: IS_IPHONE,
      ie: IE_VERSION,
      ios:
        in_browser &&
        /iPad|iPhone|iPod/.test(navigator.userAgent) &&
        !window.MSStream,
    };
    return self;
  }
  mq.window &&
    mq.window.on([Events.LOAD, Events.RESIZE], function () {
      instances.forEach(function (player) {
        var root = player.root;
        if (root.prevWidth == root.clientWidth) return;
        player.emit(Events.RESIZE);
        root.prevWidth = root.clientWidth;
      });
    });
  function tween(ele, is, was, timer) {
    if (timer) ele.addClass(states.TOGGLING);
    ele.removeClass(was);
    ele.addClass(is);
    if (timer)
      setTimeout(function () {
        ele.removeClass(states.TOGGLING);
      }, timer);
  }
  function classify(opts, root, video) {
    // tracks the state of the initial play
    var initial = true;
    root.addClass('flowplayer');
    video.on([Events.LOAD_START, Events.RESIZE], function () {
      var current_width = root.clientWidth;
      root
        .toggleClass(states.SMALL, current_width < 600)
        .toggleClass(states.TINY, current_width < 400);
    });
    video.on(Events.CONFIG, function () {
      var on = video.paused && !opts.autoplay;
      [states.LOADING, states.STARTING].forEach(function (state) {
        root.toggleClass(state, on);
      });
    });
    // is-ended
    video.on(Events.ENDED, function (e) {
      setTimeout(function () {
        if (e.defaultPrevented) return;
        // reset on rewind
        if (opts.rewind) {
          root.addClass(states.SEEKING);
          video.one(Events.SEEKED, function () {
            root.removeClass(states.SEEKING);
            if (!opts.loop) video.pause(); // https://github.com/flowplayer/flowplayer-native/issues/346
          });
          video.currentTime = 0;
          if (opts.poster) video.hide();
        }
        // restart
        // this MUST COME AFTER reset on rewind
        // or the ui will flicker oddly
        video.one(Events.TIME_UPDATE, function () {
          root.removeClass(states.ENDED);
        });
        // don't animate big buttons
        // issues/179
        tween(
          root,
          states.ENDED,
          states.PLAYING,
          opts.loop || opts.rewind ? 0 : 300,
        );
      }, 0);
    });
    video.on([Events.SEEKING, Events.SEEKED], function (e) {
      root.toggleClass(states.SEEKING, e.type == Events.SEEKING);
    });
    video.on(Events.ENDED, function () {
      // the next play will be an initial play
      // whether it's a loop or a new src
      initial = true;
    });
    // is-loading
    video.on(support().ios ? Events.METADATA : Events.DATA, function (e) {
      var is_loaded = e.type != 'src' || !(opts.preload == 'none');
      root.toggleClass(states.LOADED, is_loaded);
      root.toggleClass(states.LOADING, !is_loaded);
    });
    // progress
    video.on(
      [Events.WAITING, Events.CAN_PLAY, Events.LOAD_START],
      function (e) {
        // prevent waiting animation flicker on seeking
        if (root.hasClass(states.SEEKING)) return;
        // if the video can play we are not waiting on anything
        if (e.type == Events.CAN_PLAY) video.removeClass(states.WAITING);
        // don't toggle waiting on lazily loaded videos
        // that are not autoplaying
        if (
          e.type == Events.LOAD_START &&
          opts.preload == 'none' &&
          !opts.autoplay
        )
          return;
        // turn on waiting animation as early as possible otherwise
        //
        // issue: https://github.com/flowplayer/flowplayer-native/issues/223
        //        make sure we have a clean state
        [states.PLAYING, states.PAUSED].forEach(root.toggleClass);
        // we are no longer ended
        root.removeClass(states.ENDED);
        // if the video is not playing do not usurp the UI state
        // if (video.paused) return
        // these events can trigger a waiting UI state
        var triggering_events = [Events.WAITING];
        // apply the waiting state
        root.toggleClass(
          states.WAITING,
          triggering_events.indexOf(e.type) > -1,
        );
      },
    );
    // paused
    video.on([Events.PLAYING, Events.PAUSE], function (e) {
      var playing$$1 = e.type == Events.PLAYING;
      var finished = video.currentTime == video.duration;
      var autoplay_start = playing$$1 && initial && opts.autoplay;
      var skip_toggle =
        autoplay_start ||
        root.hasClass(states.SEAMLESS) ||
        root.hasClass(states.WAITING);
      // mark this video as having started
      if (playing$$1) {
        video.started = true;
        video.show();
      }
      // remove seamless after initial startup on autoplay
      if (!opts.seamless && initial) root.removeClass(states.SEAMLESS);
      // toggle initial to be false on the first playing event
      if (playing$$1) initial = false;
      // make sure waiting is removed on Safari
      root.removeClass(states.WAITING).removeClass(states.STARTING);
      // issues/179 - this is handled in on(END)
      if (finished || root.hasClass(states.SEEKING)) return;
      // remove the initial starting state
      if (initial) root.removeClass(states.STARTING);
      var is = playing$$1 ? states.PLAYING : states.PAUSED;
      var was = playing$$1 ? states.PAUSED : states.PLAYING;
      tween(root, is, was, skip_toggle ? 0 : 300);
      if (playing$$1) video.show();
    });
  }
  var DEFAULT_ASPECT_RATIO = '0.5625' * 1;
  function parse_ratio(ratio) {
    if (typeof ratio == 'number' && !isNaN(ratio)) return Number(ratio);
    if (typeof ratio == 'string') {
      var parts = ratio.split(':');
      return Number(parts[1]) / Number(parts[0]);
    }
    return ratio;
  }
  function aspect_ratio_plugin(opts, root, video) {
    var ele = {
        class: 'fp-ratio',
      },
      aspect_ratio = mq.div(ele);
    aspect_ratio.set = function (ratio) {
      ratio = parse_ratio(ratio || DEFAULT_ASPECT_RATIO);
      aspect_ratio.css(
        'padding-top',
        !isNaN(ratio) ? ratio * 100 + '%' : ratio,
      );
    };
    root.reaper.put('aspect_ratio', aspect_ratio);
    root.append(aspect_ratio);
    video.on(Events.METADATA, function () {
      aspect_ratio.set(
        opts.ratio ||
          (video.videoHeight &&
            video.videoWidth &&
            video.videoHeight / video.videoWidth),
      );
    });
    video.on(Events.CONFIG, function (e) {
      aspect_ratio.set(
        lens(
          e,
          'data.ratio',
          video.videoHeight &&
            video.videoWidth &&
            video.videoHeight / video.videoWidth,
        ),
      );
    });
  }
  // autoplay + viewport functionality
  /**
   * calculate if a root wrapper is visible in the current viewport
   *
   * @param      {DOMElement}  root    The root
   * @return     {Boolean}             true if visible, false otherwise
   */
  function in_viewport(root) {
    var rect = root.getBoundingClientRect(),
      view_height = window.innerHeight,
      player_height = rect.height,
      bottom = rect.bottom,
      // 20% safety zone
      offset = player_height / 5;
    // taller than viewport || top edges hidden
    return (
      (rect.top <= offset && rect.top + player_height > view_height - offset) ||
      (bottom - player_height + offset >= 0 && bottom < view_height + offset)
    );
  }
  /**
   * checks if a player is currently visible
   * and announces any visibility changes
   *
   * @param      {Flowplayer}  player  The player
   * @return     {Flowplayer}          The player
   */
  function update_visible(player) {
    var currently_visible = in_viewport(player.root);
    if (player.in_viewport === currently_visible) return player;
    // persist the visibility change
    player.in_viewport = currently_visible;
    // emit it to anything that wants to listen
    player.emit(currently_visible ? Events.VIEW_ENTER : Events.VIEW_LEAVE);
    return player;
  }
  mq.window &&
    mq.window.on(Events.SCROLL, function _onscroll() {
      instances.forEach(update_visible);
    });
  function viewport(opts, _root, video) {
    update_visible(video).on(Events.VIEW_LEAVE, video.pause);
    // only register this listener if we care about autoplay
    video.on([Events.CAN_PLAY, Events.VIEW_ENTER], function (_e) {
      if (!opts.autoplay || playing().size) return;
      if (video.in_viewport && video.paused && !video._play_toggled) {
        return video.togglePlay(true);
      }
    });
  }
  var extensions = [classify, aspect_ratio_plugin, viewport];
  function loaders() {
    return extensions.filter(function (ext) {
      return typeof ext.wants == 'function';
    });
  }
  /**
   * coverts a property walker into a string
   */
  function stringify(prop) {
    return Array.isArray(prop) ? prop.join('.') : prop;
  }
  /**
   * sorts properties by depth
   */
  function desc(a, b) {
    return b.length - a.length;
  }
  /**
   * handle Object disposal and garbage collecting of nodes
   */
  function Reaper(tree) {
    if (typeof tree === 'undefined') return;
    if (tree.reaper) return tree.reaper;
    if (!(this instanceof Reaper)) return new Reaper(tree);
    var reaper = (tree.reaper = this);
    reaper.tree = tree;
    reaper.props = [];
    /**
     * adds a property to our disposal tree
     */
    reaper.push = function (props) {
      reaper.props = reaper.props.concat(props);
      return reaper;
    };
    /**
     * puts a value that can later be disposed at the given path
     */
    reaper.put = function (path, val) {
      reaper.push(path);
      put(tree, path, val);
      return val;
    };
    /**
     * prune the Object tree of unsafe references
     */
    reaper.run = function (running) {
      // track running reapers to handle cyclical references
      running = Array.isArray(running) ? running : [];
      running.push(reaper);
      // call the deepest paths first so they cannot
      // become dettached
      var props = reaper.props.map(stringify).sort(desc);
      while (props.length) {
        var prop = props.shift();
        var val = lens(tree, prop);
        // walk the reapers to clean up entire tree
        if (val && val.reaper && !~running.indexOf(val.reaper)) {
          val.reaper.run(running);
        }
        put(tree, prop, 0);
      }
      for (var own in reaper) {
        delete reaper[own];
      }
      delete running[running.indexOf(reaper)];
      tree.reaper = 0;
    };
    return reaper;
  }
  function singleton_methods(flowplayer) {
    flowplayer.version = '1.2.1';
    flowplayer.commit = 'e22900438db24de25ea379a65d05617f5c9cfbd6';
    flowplayer.Players = Players;
    flowplayer.instances = instances;
    flowplayer.extensions = extensions;
    flowplayer.loaders = loaders;
    flowplayer.support = support;
    flowplayer.events = Events;
    flowplayer.states = states;
    flowplayer.mq = mq;
    flowplayer.util = util;
    flowplayer.observable = observable;
    flowplayer.Reaper = Reaper;
  }
  /**
   * syncs the state of a Flowplayer instance
   * with the other flowplayer instances
   */
  function sync_play_state(video, opts) {
    // should not toggle other instances if multiplay is enabled
    if (opts.multiplay) return;
    // pause other players
    instances.forEach(function (other) {
      if (video == other) return;
      other.toggleFullScreen(false);
      other.pause();
    });
  }
  function no_autoplay(video) {
    var root = video.root;
    root.removeClass(states.AUTOPLAY);
    root.removeClass(states.WAITING);
    root.addClass(states.NO_AUTOPLAY);
  }
  function absorb_promised_play(promise, video, opts) {
    var original_muted_opt = opts.muted;
    // bubble this promise chain to outside world
    // issue/188
    return promise
      .catch(function (err) {
        // Firefox throws this error in an odd way
        if (!video.paused) return;
        // this can be returned-early
        // it means a gesture is required on iOS
        if (err.name == 'AbortError' && err.code == 20)
          return no_autoplay(video);
        // try  to recover on promises
        // where autoplay can only be muted autoplay
        opts.muted = true;
        video.toggleMute(true);
        video.volume = 0;
        return video.play();
      })
      .then(function () {
        sync_play_state(video, opts);
      })
      .catch(function (err) {
        opts.autoplay = false;
        opts.muted = original_muted_opt;
        video.toggleMute(false);
        // We attempted and failed to autoplay
        if (!video.started) return no_autoplay(video);
        console.error(err);
        video.emit(Events.ERROR, err);
      });
  }
  /**
   * handles play/pause state swapping
   * and safely degrades on autoplay failures
   * to autoplay + muted
   */
  function toggle_play(video, opts, flag) {
    // setup next state
    if (typeof flag != 'boolean') flag = video.paused;
    try {
      // this is a Promise on newer promises
      var promise = flag ? video.play() : video.pause(),
        is_promise = promise && typeof promise.catch == 'function';
      // handle asynchronous autoplay startup
      // issue/188
      if (is_promise) return absorb_promised_play(promise, video, opts);
      // was a synchronous platform, but video did not resume playing
      // so autoplay has been disabled
      if (video.paused && flag && video.currentTime == 0) no_autoplay(video);
      // or if the didn't say to autoplay
      sync_play_state(video, opts);
    } catch (err) {
      video.emit(Events.ERROR, err);
    }
  }
  /**
   * fetches the extension name from a path
   */
  function extname(path) {
    var val = path.split('/').slice(-1)[0].split('.')[1];
    return val && val.split('?')[0];
  }
  /**
   * map guessed mime types
   * to valid mime types
   */
  function lookup(type) {
    switch (type) {
      case 'video/m3u8':
        return 'application/x-mpegurl';
      default:
        return type;
    }
  }
  /**
   * parses a source to a Array<[src, type]>
   */
  function parse(src) {
    var els = src.split('{'),
      types = els[1];
    if (!types) {
      var ext = extname(src);
      return [
        {
          src: src,
          type: lookup('video/' + ext),
        },
      ];
    }
    return types
      .slice(0, -1)
      .split(',')
      .map(function (type) {
        return {
          src: els[0] + type,
          type: lookup('video/' + type),
        };
      });
  }
  var ATTRS = ['loop', 'muted', 'preload', 'autoplay'];
  /**
   * serialize a TimeRange to an Array
   *
   * @param      {TimeRange}    range   The range
   * @return     {Array}                The array representation of the TimeRange
   */
  function serialize_time_range(range) {
    var data = Array(range.length),
      i = 0;
    if (range.length == 0) return data;
    while (i < range.length) {
      data[i] = [range.start(i), range.end(i)];
      i++;
    }
    return data;
  }
  function api(opts, root, video) {
    video.toJSON = function toJSON() {
      return {
        duration: video.duration,
        volume: video.volume,
        currentTime: video.currentTime,
        buffered: serialize_time_range(video.buffered),
        played: serialize_time_range(video.played),
        states: video.root.className,
      };
    };
    video.setSrc = function (src) {
      if (typeof src == 'string') src = parse(src);
      if (typeof src.forEach !== 'function') src = [src];
      // clear previous clip
      if (video.currentSrc) video.innerHTML = '';
      src.forEach(function (data, i) {
        if (typeof data == 'string')
          data = {
            src: data,
          };
        // custom event *before* the video set
        video.emit(Events.SOURCE, {
          src: data.src,
        });
        // this will preserve load order
        // with respect to plugins, so that the plugin
        // loaded first is given precendence
        var matched_loaders = loaders().filter(function (ext) {
          // https://github.com/flowplayer/flowplayer-native/issues/249
          // plugins must have a way to inspect config state
          // during wants
          return ext.wants(data.src, data, opts);
        });
        // if some external loader wants this source type
        // then forward it to the loader
        // this allows a plugin to match based on arity if they are
        // in startup (3 arguments) or in loading (4 arguments)
        if (matched_loaders.length) {
          var ran = matched_loaders.pop().call(video, opts, root, video, data);
          // if the plugin ran then let it do what it wants
          if (ran !== false) return;
        }
        // otherwise treat it as a pure native source
        video
          .append(mq('<source>', data))
          .on(Events.ERROR, function source_failed(e) {
            e.target.remove();
            // only throw error on last source
            if (i < src.length - 1) return;
            var code = video.canPlayType(data.type) ? 4 : 5,
              path = data.src;
            video.emit(Events.ERROR, {
              message:
                code == 4
                  ? 'Video not found: ' + path
                  : (data.type || path) + ' is not supported',
              videoType: data.type,
              code: code,
              src: path,
            });
          });
      });
      // we are using normal browser supported video types
      // so we should always render the UI
      if (video.currentSrc) video.load();
      if (opts.preload == 'none') video.render();
      return video;
    };
    video.render = function () {
      video.emit(support().ios ? Events.METADATA : Events.DATA);
      video.emit(Events.CAN_PLAY);
      return video;
    };
    video.togglePlay = function (flag, cb) {
      // issue/188
      var maybe_promise = toggle_play(video, opts, flag);
      if (typeof cb !== 'function') return maybe_promise;
      if ('catch' in maybe_promise) return maybe_promise.then(cb);
      return cb();
    };
    video.toggleMute = function (flag) {
      if (typeof flag != 'boolean') flag = !video.disabled;
      video.muted = !video.muted;
      if (!video.muted && !video.volume) video.volume = 0.5;
      video.emit(Events.VOLUME_CHANGE);
    };
    video.toggleDisable = function (flag) {
      if (typeof flag != 'boolean') flag = !video.disabled;
      root.toggleClass(states.DISABLED, flag);
      video.disabled = flag;
    };
    video.destroy = function (cb) {
      video.pause(); // clear all requestAnimationFrames
      var idx = instances.indexOf(video);
      if (~idx) instances.splice(idx, 1);
      root.emit(Events.REAP);
      setTimeout(function () {
        video.setSrc([]);
        if ('function' == typeof cb) cb();
      }, 0); // empty streams
    };
    video.setAttrs = function (attrs) {
      ATTRS.forEach(function (name) {
        var val = as_bool(attrs[name]);
        if (val) {
          video.attr(name, val);
          if (name in video) video[name] = val;
          return;
        }
        if (val === false) {
          video.removeAttribute(name);
          if (name in video) video[name] = val;
        }
      });
    };
    video.setOpts = function (update) {
      extend(opts, update);
      root.toggleClass(states.AUTOPLAY, !!opts.autoplay);
      root.toggleClass(states.RTL, !!opts.rtl);
      root.toggleClass(states.LIVE, !!opts.live);
      root.toggleClass(states.NO_DVR, !!(opts.live && !opts.dvr));
      root.toggleClass(states.SEAMLESS, !!(opts.seamless || opts.autoplay));
      // poster as background image == best cross browser support & works with preload="none"
      if (opts.poster) {
        root.css('background-image', 'url(' + opts.poster + ')');
        // hide video so poster shows
        if (video.paused) video.hide();
      }
      video.emit(Events.CONFIG, opts);
    };
  }
  function Player(conf, root) {
    var $async = root.querySelector('video'),
      player = mq($async || document.createElement('video'));
    player.addClass('fp-engine');
    Reaper(player);
    player.async = typeof $async !== 'undefined';
    // async previously played
    if (player.async && !player.paused) {
      root.addClass(states.PLAYING).addClass(states.SEAMLESS);
      return player;
    }
    player.attr('playsinline', '');
    player.attr('webkit-playsinline', '');
    root.append(player);
    return player;
  }
  var READY = ['complete', 'interactive', 'loaded'];
  function available(cb) {
    if (typeof document == 'undefined' || ~READY.indexOf(document.readyState))
      return cb();
    document.addEventListener('DOMContentLoaded', cb);
  }
  function is_rtl() {
    if (typeof document == 'undefined') return false;
    var $docEle = document.documentElement;
    return ($docEle && $docEle.getAttribute('dir') == 'rtl') || false;
  }
  /**
   * adds support for asynchronous plugin loading`
   * issue/127
   */
  function root() {
    if (typeof window !== 'undefined') return window;
    // eslint-disable-next-line no-undef
    if (typeof global !== 'undefined') return global;
    return {};
  }
  function modules() {
    var self = root();
    // naively check for existance of flowplayer umd
    var mod = self.flowplayer
      ? self.flowplayer
      : {
          extensions: [],
        };
    if (!Array.isArray(mod.extensions)) mod.extensions = [];
    return mod;
  }
  function check_token$$1(str) {
    try {
      Token.validate(str);
      return {
        success: true,
      };
    } catch (e) {
      return invalid(e.message);
    }
  }
  function invalid(msg) {
    return {
      success: false,
      message: msg,
    };
  }
  var WHITELIST = ['localhost', '127.0.0.1', '0.0.0.0', 'codepen.io'];
  function check_domain(actual, domain) {
    if (~WHITELIST.indexOf(actual)) return true;
    return actual.indexOf(domain) === actual.length - domain.length;
  }
  /**
   * The code was extracted from:
   * https://github.com/davidchambers/Base64.js
   */
  var chars =
    'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
  function InvalidCharacterError(message) {
    this.message = message;
  }
  InvalidCharacterError.prototype = new Error();
  InvalidCharacterError.prototype.name = 'InvalidCharacterError';
  function polyfill(input) {
    var str = String(input).replace(/=+$/, '');
    if (str.length % 4 == 1) {
      throw new InvalidCharacterError(
        "'atob' failed: The string to be decoded is not correctly encoded.",
      );
    }
    for (
      // initialize result and counters
      var bc = 0, bs, buffer, idx = 0, output = '';
      // get next character
      (buffer = str.charAt(idx++));
      // character found in table? initialize bit storage and add its ascii value;
      ~buffer && ((bs = bc % 4 ? bs * 64 + buffer : buffer), bc++ % 4)
        ? (output += String.fromCharCode(255 & (bs >> ((-2 * bc) & 6))))
        : 0
    ) {
      // try to find character in table (0-63, not found => -1)
      buffer = chars.indexOf(buffer);
    }
    return output;
  }
  var atob =
    (typeof window !== 'undefined' &&
      window.atob &&
      window.atob.bind(window)) ||
    polyfill;
  function b64DecodeUnicode(str) {
    return decodeURIComponent(
      atob(str).replace(/(.)/g, function (m, p) {
        var code = p.charCodeAt(0).toString(16).toUpperCase();
        if (code.length < 2) {
          code = '0' + code;
        }
        return '%' + code;
      }),
    );
  }
  var base64_url_decode = function (str) {
    var output = str.replace(/-/g, '+').replace(/_/g, '/');
    switch (output.length % 4) {
      case 0:
        break;
      case 2:
        output += '==';
        break;
      case 3:
        output += '=';
        break;
      default:
        throw 'Illegal base64url string!';
    }
    try {
      return b64DecodeUnicode(output);
    } catch (err) {
      return atob(output);
    }
  };
  function InvalidTokenError(message) {
    this.message = message;
  }
  InvalidTokenError.prototype = new Error();
  InvalidTokenError.prototype.name = 'InvalidTokenError';
  var lib = function (token, options) {
    if (typeof token !== 'string') {
      throw new InvalidTokenError('Invalid token specified');
    }
    options = options || {};
    var pos = options.header === true ? 0 : 1;
    try {
      return JSON.parse(base64_url_decode(token.split('.')[pos]));
    } catch (e) {
      throw new InvalidTokenError('Invalid token specified: ' + e.message);
    }
  };
  var InvalidTokenError_1 = InvalidTokenError;
  lib.InvalidTokenError = InvalidTokenError_1;
  function Token(str, opts) {
    var token_data = {},
      token = this;
    opts = opts || {};
    try {
      token_data = lib(str);
      token.valid_jwt = true;
    } catch (e) {
      /**/
    }
    token.raw = str;
    token.data = JSON.parse(token_data.c || '{}');
    token.exp = token_data.exp;
    if (opts.require_valid_token) Token.validate(token);
  }
  Token.validate = function (token) {
    if (typeof token === 'string') token = new Token(token);
    if (!token || !token.raw) {
      if ('localhost' === window.location.hostname || 'production' === 'dev')
        return true;
      throw new Error('No token provided in configuration');
    }
    if (!token.valid_jwt) throw new Error('Invalid token provided');
    var h = window.location.hostname,
      c = check_domain.bind(null, h);
    if (
      token.data.domain &&
      token.data.domain.length &&
      !token.data.domain.some(c)
    )
      throw new Error('Domain not allowed');
    if (token.exp * 1000 - Date.now() < 0) throw new Error('Expired token');
    return true;
  };
  Token.id = function (token) {
    if (!token) return;
    if (typeof token === 'string') token = new Token(token);
    return token.data.id;
  };
  // issue/127
  var prefetched = modules();
  /**
   * flowplayer initializer
   */
  function flowplayer$1(arg, opts) {
    // extension
    if (typeof arg == 'function') {
      for (var i = 0; i < arguments.length; ++i) extensions.push(arguments[i]);
      return;
    }
    // opts as string
    if (typeof opts == 'string')
      opts = {
        src: opts,
      };
    // default opts
    opts = extend(
      {
        rtl: is_rtl(),
        controls: true,
        preload: 'none',
      },
      opts,
    );
    // root
    var root$$1 = mq(arg);
    /*eslint no-console: 0*/
    if (!root$$1)
      return console.error(
        new Error("Flowplayer: '" + arg.toString() + "' not found"),
      );
    // noop on double-invoke
    if (root$$1.video) return root$$1.video;
    var v = check_token$$1(opts.token);
    if (!v.success)
      return fatal_error(root$$1, null, {
        reason: 'token',
        details: v.message,
      });
    // attach garbage collection for SPAs
    var reaper = Reaper(root$$1);
    root$$1.once(Events.REAP, reaper.run);
    // poor flex fallbacks for old IE
    if (support().ie > 0) root$$1.addClass('poor-flex');
    // no video support --> <img src={opts.poster}>
    if (!support().video)
      return root$$1.append(
        mq.img({
          src: opts.poster,
        }),
      );
    var video = reaper.put('video', Player(opts, root$$1));
    reaper.put('video.root', root$$1);
    !~instances.indexOf(video) && instances.push(video);
    // make sure the API is available before
    // plugins are called
    api(opts, root$$1, video);
    video.setAttrs(opts);
    // extend the <video> tag instance (not the prototype)
    extensions.forEach(function (ext) {
      ext.call(flowplayer$1, opts, root$$1, video);
    });
    // expose this to the world
    // but add it to GC reference counter
    // so it can be cleaned up
    video.reaper.put('opts', opts);
    // give all plugins a chance to
    // attach OPTIONS listeners
    video.setOpts(opts);
    opts.src && video.setSrc(opts.src);
    var readyState = video.readyState;
    if (readyState > 0 && video.currentSrc) video.emit(Events.METADATA);
    if (readyState > 2 && video.currentSrc) video.emit(Events.CAN_PLAY);
    if (opts.preload == 'none' && video.paused && video.currentSrc) {
      video.render();
    }
    video.emit(Events.MOUNT);
    video.on(Events.NON_RECOVERABLE_ERROR, function (ev) {
      fatal_error(root$$1, video, ev.data);
    });
    return video;
  }
  prefetched.extensions.forEach(function (extension) {
    extensions.push(extension);
  });
  assign(flowplayer$1, prefetched);
  singleton_methods(flowplayer$1);
  function fatal_error(root$$1, video, data) {
    if (video) video.destroy();
    root$$1.innerHTML = '';
    root$$1.removeClass('flowplayer');
    root$$1.addClass('flowplayer-fatal');
    root$$1.append(mq.el('h2', {}, 'Playback error'));
    root$$1.append(mq.p({}, 'Are you the site owner?'));
    root$$1.append(
      mq.a(
        {
          className: 'troubleshoot',
          target: '_blank',
          href:
            'https://flowplayer.com/help/developers/troubleshooting?reason=' +
            data.reason,
        },
        'Troubleshoot',
      ),
    );
    root$$1.append(
      mq.a(
        {},
        mq.img({
          src: 'https://flowplayer.com/user/pages/images/logo-white.png',
        }),
      ),
    );
    console.error(new Error(data.details || data.reason));
  }
  var PING = [
    'siteGroupId',
    'siteId',
    'id',
    'created',
    'sessionId',
    'position',
  ];
  var REQUEST = [
    'siteGroupId',
    'siteId',
    'id',
    'playerId',
    'playerVersion',
    'sessionId',
    'deviceInfo',
    'created',
    'source',
    'category',
  ];
  /**
   * this is a naive implementation of crypto.getRandomValues
   * Math.random() is notoriously broken on older browsers
   * but it is the simplest tool for this job
   */
  function pseudo_random_bytes(bytes) {
    for (var i = 0, r; i < 16; i++) {
      if ((i & 0x03) === 0) r = Math.random() * 0x100000000;
      bytes[i] = (r >>> ((i & 0x03) << 3)) & 0xff;
    }
    return bytes;
  }
  // index mapping for uuid dashes
  var dash = {
    3: true,
    5: true,
    7: true,
    9: true,
  };
  /**
   * generates a uuid
   */
  function uuid() {
    return pseudo_random_bytes(Array(16)).reduce(function (uuid, byte, i) {
      var part = (byte + 0x100).toString(16).substr(1);
      return uuid + (dash[i] ? '-' : '') + part;
    }, '');
  }
  var SESSION_ID = uuid();
  var DESKTOP = '(min-width: 1200px)';
  var TABLET = '(min-width: 600px)';
  var MOBILE = '(max-width: 599px)';
  function to_str_arr(device) {
    return [device.type, device.platform].reduce(function (str, key, i) {
      if (!key) return str;
      if (i == 0) return str + key;
      return str + ',' + key;
    }, '');
  }
  function device_info() {
    if (typeof window == 'undefined') return '';
    var device = {
      type: 'desktop',
    };
    // really old browser so probably not a phone
    if (!('matchMedia' in window)) return to_str_arr(device);
    if (window.matchMedia(DESKTOP).matches) return to_str_arr(device);
    if (support().android) device.platform = 'android';
    if (support().ios) device.platform = 'ios';
    if (window.matchMedia(TABLET).matches) {
      device.type = 'tablet';
      return to_str_arr(device);
    }
    if (window.matchMedia(MOBILE).matches) {
      device.type = 'mobile';
      return to_str_arr(device);
    }
    return to_str_arr(device);
  }
  var DEVICE_INFO = device_info();
  function Track() {
    var type = arguments[0],
      action = arguments[1];
    return function (data) {
      try {
        if (!data.siteGroupId) {
          throw new Error('no siteGroupId found');
        }
        var xhr = new XMLHttpRequest(),
          body = JSON.stringify(data),
          endpoint = [
            'https://ptm.flowplayer.com',
            type,
            data.siteGroupId,
            action,
          ].join('/');
        xhr.timeout = 2500;
        xhr.open('POST', endpoint, true);
        xhr.setRequestHeader('Content-Type', 'application/json charset=UTF-8');
        // send the collected data as JSON
        xhr.send(body);
        xhr.onloadend = xhr.ontimeout = noop;
      } catch (err) {
        console.error(err);
      }
    };
  }
  /**
   * light-weight cancellable rate-limited Ticker
   */
  function Tick(fn, ttl, args) {
    if (!(this instanceof Tick)) return new Tick(fn, ttl, args);
    var tick = this;
    tick.name = fn.name || 'Tick::anonymous::' + Date.now();
    tick.locked = false;
    tick.ttl = ttl;
    tick.unlock = function () {
      tick.locked = false;
      return tick;
    };
    /**
     * schedule a new tick to run
     */
    tick.run = function () {
      if (tick.locked) return;
      tick.locked = setTimeout(function () {
        fn.apply(null, args);
        return tick.unlock();
      }, ttl);
    };
    /**
     * cancel a pending tick
     */
    tick.cancel = function () {
      if (tick.locked) {
        clearTimeout(tick.locked);
      }
      return tick.unlock();
    };
    return tick;
  }
  var ADS = 1 << 1;
  var ANALYTICS = 1 << 2;
  var NO_METERING = 1 << 3;
  var permissions = Object.freeze({
    ADS: ADS,
    ANALYTICS: ANALYTICS,
    NO_METERING: NO_METERING,
  });
  function ACL(grant) {
    if (!(this instanceof ACL)) return new ACL(grant);
    var acl = this;
    acl.grant = grant;
    acl.is_granted = function (flag) {
      return (acl.grant & flag) === flag;
    };
  }
  ACL.of = ACL;
  ACL.from_token = function (str) {
    var token = new Token(str, {
      require_valid_token: true,
    });
    return ACL.of(token.data.acl);
  };
  ACL.permissions = permissions;
  var NUMBER_OF_SEGMENTS = 100;
  var MAX_PER_SECOND = 1 / 6;
  var SECOND = 1000;
  var RATE_LIMIT = MAX_PER_SECOND * SECOND;
  /**
   * The api for all allowed analytics calls
   */
  var Analytics = {
    vod: {
      ping: Track('vod', 'ping'),
      display: Track('vod', 'display'),
      view: Track('vod', 'view'),
    },
    live: {
      ping: Track('live', 'ping'),
      display: Track('live', 'display'),
      view: Track('live', 'view'),
    },
    ad: {
      request: Track('adrequest'),
      event: Track('adevent'),
    },
  };
  /**
   * finds the current seen chunks in a reasonably performant way
   */
  function find_seen(video, state) {
    var bounded_idx = Math.floor(video.currentTime / state.segment_duration);
    // seeked backwards
    if (bounded_idx < state.from()) {
      return state.from(bounded_idx);
    }
    var data = {
      position: state.segments
        .slice(state.from(), bounded_idx)
        .map(function (ts) {
          return state.segments.indexOf(ts);
        }),
    };
    // shift the seen window to the new subset
    state.from(bounded_idx);
    return data;
  }
  /**
   * given a video duration it generates the breakpoints for the percentage
   * based analytics chunks and segment duration
   */
  function find_segments(duration) {
    var segment_duration = duration / NUMBER_OF_SEGMENTS;
    // $FlowFixMe
    return [
      segment_duration,
      Array.apply(null, Array(NUMBER_OF_SEGMENTS)).map(function (_, i) {
        return Math.floor(i * segment_duration * 1000) / 1000;
      }),
    ];
  }
  function ping_vod(video, state, endpoint) {
    var seen = find_seen(video, state);
    // don't send empty data
    if (!seen.position.length) return;
    endpoint.ping(payload_whitelist(PING, assign({}, state.payload, seen)));
  }
  function ping_live(position, state, endpoint) {
    endpoint.ping(
      payload_whitelist(
        PING,
        assign({}, state.payload, {
          position: position,
        }),
      ),
    );
  }
  function track_vod(video, state, endpoint) {
    var ping_tick = Tick(ping_vod, 6 * SECOND, [video, state, endpoint]);
    // stores the index we have currently seen from
    state.from = box(0);
    video.once(Events.METADATA, function () {
      var timing_info = find_segments(video.duration);
      state.segments = timing_info.pop();
      state.segment_duration = timing_info.shift();
      if (video.duration > RATE_LIMIT) {
        ping_tick.ttl = state.segment_duration;
      }
      video.on(Events.TIME_UPDATE, ping_tick.run);
    });
    video.on(
      Events.SEEKED,
      function () {
        // update the state on a seek
        find_seen(video, state);
      },
      500,
    );
    video.on(Events.ENDED, function () {
      ping_tick.cancel();
      ping_vod(video, state, endpoint);
    });
  }
  function within(midpoint, band, test) {
    var upper_bound = midpoint + band.right,
      lower_bound = midpoint - band.left;
    return test < upper_bound && test > lower_bound;
  }
  var tolerance = {
    left: 5,
    right: 5,
  };
  function track_live(video, state, endpoint) {
    state.from = box(0);
    video.on(Events.TIME_UPDATE, function () {
      var watched = video.currentTime,
        next_minute = state.from() + 60;
      if (!within(next_minute, tolerance, watched)) return;
      ping_live(next_minute, state, endpoint);
      state.from(next_minute);
    });
  }
  function payload_whitelist(props, payload) {
    return props.reduce(function (acc, key) {
      acc[key] = payload[key];
      return acc;
    }, {});
  }
  var setup = function (config, state, video) {
    // nonce
    setup = noop;
    var endpoint = config.live ? Analytics.live : Analytics.vod;
    endpoint.display(payload_whitelist(REQUEST, state.payload));
    var onplaying = function () {
      endpoint.view(payload_whitelist(REQUEST, state.payload));
    };
    // has already played some
    if (video.played.length > 0) onplaying();
    else video.one(Events.PLAYING, onplaying);
    if (config.live) return track_live(video, state, endpoint);
    return track_vod(video, state, endpoint);
  };
  function analytics(config, _root, video) {
    if (!ACL.from_token(config.token).is_granted(ACL.permissions.ANALYTICS))
      return;
    var state = {};
    state.payload = {
      playerVersion: '1.2.1',
      created: new Date().toISOString(),
      sessionId: SESSION_ID,
      deviceInfo: DEVICE_INFO,
      source: encodeURI(
        document.location.href.replace(document.location.protocol + '//', ''),
      ),
    };
    video.on(Events.CONFIG, function (e) {
      var metadata = lens(e, 'data.metadata', false);
      if (!metadata || !metadata.siteGroupId) return;
      metadata.category = metadata.category_id;
      metadata.playerId = metadata.player_id;
      extend(state.payload, metadata);
      setup(config, state, video);
    });
  }
  /**
   * these events should be public
   * so it is easier to build things on them
   */
  var LANDSCAPE = (Events.LANDSCAPE = 'landscape');
  var PORTRAIT = (Events.PORTRAIT = 'portrait');
  /**
   * orients a single player
   * based on a landscape media query
   */
  function orient(type) {
    window
      .matchMedia('(orientation: ' + type + ')')
      .addListener(function (query) {
        instances.length &&
          instances.forEach(function (instance) {
            if (query.matches) instance.emit(type);
          });
      });
  }
  /**
   * listen for changes on landscape media query matches
   * so that the video can go fullscreen on mobile
   */
  if (typeof window !== 'undefined' && window.matchMedia)
    [LANDSCAPE, PORTRAIT].forEach(orient);
  /**
   * attaches auto fullscreen on landscape mode
   * for mobile
   */
  function orientationchange(opts, root, video) {
    if (!(support().ios || support().android)) return;
    video.on([LANDSCAPE, PORTRAIT], function (e) {
      if (opts.multiplay || opts.auto_orient == false || video.paused) return;
      video.toggleFullScreen(e.type == LANDSCAPE);
      window.getComputedStyle(root);
    });
  }
  /**
   * these events should be public
   * so it is easier to build things on them
   */
  var TOUCH_END = (Events.TOUCH_END = 'touchend');
  var IS_TOUCHED = (states.TOUCHED = 'is-touched');
  var IS_TOUCH_DEVICE = (states.IS_TOUCH_DEVICE = 'is-touch-device');
  function ontouch(_opts, root, video) {
    if (typeof window !== 'undefined' && 'ontouchstart' in window)
      root.addClass(IS_TOUCH_DEVICE);
    // allocate a timeout for touch
    var timer;
    root.middle.on(TOUCH_END, function (e) {
      // do not propogate click events
      // so we can do mobile specific behaviors
      e.preventDefault();
      video.emit(e.type, e.data);
    });
    // you cannot call HTMLVideoElement.prototype.play()
    // from within TOUCH_START
    video.on(TOUCH_END, function (e) {
      // https://github.com/flowplayer/flowplayer-native/issues/301
      setTimeout(function () {
        if (e.defaultPrevented) return;
        // one-touch replay
        // https://github.com/flowplayer/flowplayer-native/issues/142
        if (video.ended) return video.togglePlay(true);
        var first_touch = root.hasClass(states.STARTING);
        // reset timer
        if (timer) clearTimeout(timer);
        // first touch should automatically
        // start playing the video & if a previous
        // touch is valid we should toggle the playing state
        if (first_touch || root.hasClass(IS_TOUCHED)) {
          if (root.hasClass(IS_TOUCHED)) {
            root.removeClass(IS_TOUCHED);
            root.removeClass('is-hovered');
          }
          video.togglePlay();
          if (first_touch) return;
        }
        // handle first touch on a video
        // that has already started
        root.addClass(IS_TOUCHED);
        // touch menu should be shown on paused menu
        if (video.paused) return;
        // make a 2 second window where another
        // touch can toggle the state
        timer = setTimeout(function () {
          timer = 0;
          root.removeClass(IS_TOUCHED);
          // https://github.com/flowplayer/flowplayer-native/issues/318
          root.removeClass('is-hovered');
        }, 2000);
      }, 0);
    });
  }
  /**
   * attaches all mobile or mobile-like behaviors
   */
  function mobile(opts, root, video) {
    [orientationchange, ontouch].forEach(function (behavior) {
      behavior(opts, root, video);
    });
  }
  var $doc = mq.document;
  function slide(root, opts) {
    var offset, max, prev;
    // only init once
    if ('grabbing' in root) return root;
    root.grabbing = false;
    var onseek = opts.onseek || noop,
      onstart = opts.onstart || noop,
      onend = opts.onend || noop,
      onmouse = opts.onmouse || noop,
      ctx = opts.ctx;
    // root dimensions can change
    function calc() {
      offset = root.offset().left;
      max = root.clientWidth;
    }
    function value(e) {
      max || calc();
      var val = e.pageX - offset;
      if (val > max) val = max;
      if (val < 0) val = 0;
      return Math.round((val / max) * 100);
    }
    function move(e) {
      var val = value(e);
      if (val == prev) return;
      onseek.call(ctx, val, root);
      prev = val;
    }
    root.on(Events.MOUSE_DOWN, function (e) {
      $doc.on(Events.MOUSE_MOVE, move);
      root.grabbing = true;
      onstart.call(ctx, root);
      e.preventDefault();
      move(e);
    });
    root.on(Events.MOUSE_MOVE, function (e) {
      onmouse.call(ctx, value(e), root);
    });
    // remove listener
    $doc.on(Events.MOUSE_UP, function () {
      $doc.off(Events.MOUSE_MOVE, move);
      root.grabbing = false;
      onend.call(ctx, root);
      max = 0;
    });
    return root;
  }
  /**
   * this is a safer localStorage wrapper
   *
   * - localStorage throws exceptions in Safari icognito mode
   * - maybe not accessible in all target browsers
   *
   * @return     {Object}  localStorage wrapper
   */
  var storage = new (function () {
    // localStorage fallback
    // for incognito or cookie-less contexts
    function NullSink() {
      this.getItem = this.removeItem = this.setItem = noop;
    }
    // safe-accessor for storage
    // gh:issue/224
    function storage() {
      try {
        return window.localStorage || new NullSink();
      } catch (err) {
        return new NullSink();
      }
    }
    // safely expose an api method
    function expose(method, _default) {
      var api = storage();
      return function () {
        try {
          return api[method].apply(api, arguments);
        } catch (err) {
          return _default;
        }
      };
    }
    // expose API
    this.removeItem = expose('removeItem');
    this.getItem = expose('getItem', null);
    this.setItem = expose('setItem');
  })();
  /**
   * create an SVG namespaced element
   * @param {String} kind
   */
  function create_svg_ns(kind) {
    var ele = document.createElementNS('http://www.w3.org/2000/svg', kind);
    return ele;
  }
  function view_box(opts) {
    var box = create_svg_ns('svg');
    box.setAttribute('viewBox', opts.coords);
    opts.name && box.setAttribute('class', opts.name);
    box.appendChild(use(opts.link));
    return mq(box);
  }
  function use(id) {
    var $use = create_svg_ns('use');
    $use.setAttributeNS('http://www.w3.org/1999/xlink', 'xlink:href', id);
    return $use;
  }
  function from_string(svg) {
    if (typeof DOMParser == 'undefined') return;
    var unsafe = new DOMParser().parseFromString(svg, 'image/svg+xml'),
      library = document.importNode(unsafe.documentElement, true);
    // prevent asynchronous flicker
    library.style.display = 'none';
    document.body.appendChild(library);
  }
  var ENTER_FULLSCREEN = {
    coords: '-1 -2 40 30',
    name: 'fp-fullscreen',
    link: '#fp-fs',
  };
  var EXIT_FULLSCREEN = {
    coords: '-1 -2 40 30',
    name: 'fp-fullscreen-exit',
    link: '#fp-exit',
  };
  var PLAY_1 = {
    coords: '-2 -2 50 50',
    name: 'fp-play',
    link: '#fp-play',
  };
  var PAUSE_1 = {
    coords: PLAY_1.coords,
    name: 'fp-pause',
    link: '#fp-pause',
  };
  var PLAY_2 = {
    coords: PLAY_1.coords,
    name: 'fp-play fp-play-stroke',
    link: '#fp-play-stroke',
  };
  var PAUSE_2 = {
    coords: PLAY_1.coords,
    name: 'fp-pause fp-pause-stroke',
    link: '#fp-pause-stroke',
  };
  var PLAY_3 = {
    coords: PLAY_1.coords,
    name: 'fp-play fp-play-circle',
    link: '#fp-play-circle',
  };
  var PAUSE_3 = PAUSE_2;
  var VOLUME$1 = {
    coords: '-2 -2 36 58',
    link: '#fp-volume',
  };
  var SMALL_PLAY = {
    coords: '-2 -2 50 50',
    link: '#fp-play',
    name: 'fp-small-play',
  };
  var SMALL_PAUSE = {
    coords: '-2 -2 50 50',
    link: '#fp-pause',
    name: 'fp-small-pause',
  };
  var icons = Object.freeze({
    ENTER_FULLSCREEN: ENTER_FULLSCREEN,
    EXIT_FULLSCREEN: EXIT_FULLSCREEN,
    PLAY_1: PLAY_1,
    PAUSE_1: PAUSE_1,
    PLAY_2: PLAY_2,
    PAUSE_2: PAUSE_2,
    PLAY_3: PLAY_3,
    PAUSE_3: PAUSE_3,
    VOLUME: VOLUME$1,
    SMALL_PLAY: SMALL_PLAY,
    SMALL_PAUSE: SMALL_PAUSE,
  });
  var AUDIO = (typeof Audio == 'function' && new Audio()) || {};
  var VOLUME = 'volume';
  var MUTE = 'mute';
  var COLOR = 'fp-color';
  /*
    stackoverflow.com/questions/12301435/html5-video-tag-volume-support
    - enough coverage in 2016
  */
  AUDIO.volume = 0.1;
  function create_volume_bar() {
    return mq.div('fp-volume');
  }
  function volume(opts, controls, video) {
    if (!opts.controls) return;
    var $bar = create_volume_bar(),
      $volume = inject_bar.call(video, $bar, onseek, opts.rtl, video.root),
      mute_button = mq.div('fp-volumebtn', view_box(VOLUME$1));
    controls.append(mute_button);
    if (AUDIO.volume == 0.1) controls.append($bar);
    if (opts.muted_initially)
      storage.setItem(MUTE, opts.muted_initially == true);
    mute_button && mute_button.on(Events.CLICK, video.toggleMute);
    // mute
    video.on(Events.VOLUME_CHANGE, function () {
      var muted = video.volume == 0 || video.muted;
      video.root.toggleClass(states.MUTED, muted);
      storage.setItem(MUTE, muted);
      if (muted) return $volume.adjust(0);
      if (!$volume.grabbing) $volume.adjust(video.volume);
    });
    if (storage.getItem(MUTE) == 'true') {
      video.muted = true;
      video.root.toggleClass(states.MUTED, video.muted);
    }
    // muted initially
    if (opts.muted_initially) {
      video.volume = 0;
      video.one(Events.PAUSE, function () {
        video.volume = 1 * (storage.getItem(VOLUME) || 0.5);
        video.play();
      });
      return $volume;
    }
    // set stored volume
    var stored = storage.getItem(VOLUME);
    if (typeof stored == 'string') {
      // cast to Number
      video.volume = stored * 1;
    }
    video.emit(Events.VOLUME_CHANGE);
    return $volume;
  }
  function onseek(amount, $volume) {
    if (amount > 0) {
      this.muted = false;
      storage.removeItem(MUTE);
    }
    storage.setItem(VOLUME, (this.volume = amount / 100));
    $volume.adjust(this.volume);
  }
  function inject_bar(container, handler, rtl, root) {
    var ticks = 10;
    container.empty();
    if (root.hasClass('is-small')) ticks = 8;
    if (root.hasClass('is-tiny')) ticks = 6;
    // make it a slider
    slide(container, {
      onseek: handler,
      ctx: this,
    });
    // number of ticks
    extend_volume_slider(container, ticks, rtl);
    return container;
  }
  volume.inject_bar = inject_bar;
  /**
   * creates a Tick
   */
  function Tick$1() {
    return mq.i('fp-tick');
  }
  volume.Tick = Tick$1;
  /**
   * pure Function to turn a tick on
   */
  Tick$1.on = function (tick) {
    tick.addClass(COLOR);
  };
  /**
   * pure Function to turn a tick off
   */
  Tick$1.off = function (tick) {
    tick.removeClass(COLOR);
  };
  /**
   * events a volume bar with a number of ticks to represent the state
   * and the ability to adjust its width
   */
  function extend_volume_slider(bar, n, rtl) {
    var ticks = Array.apply(null, Array(n)).map(Tick$1);
    bar.append(ticks);
    /**
     * adjust the bar width to display a number of ticks
     */
    bar.adjust = function adjust(amount) {
      amount = amount * 100;
      var perc = (rtl ? 100 - amount : amount) / 100,
        level = Math.round(perc * n);
      ticks.slice(level, n).forEach(Tick$1.off);
      ticks.slice(0, level).forEach(Tick$1.on);
    };
    return bar;
  }
  volume.extend_volume_slider = extend_volume_slider;
  !(function () {
    var $doc = mq.document;
    if (!$doc) return;
    // fullscreenchange, fullscreenElement
    $doc.on(
      'webkitfullscreenchange mozfullscreenchange MSFullscreenChange msfullscreenchange',
      function () {
        $doc.emit(
          Events.FULLSCREEN_CHANGE,
          $doc.fullscreenElement ||
            $doc.webkitFullscreenElement ||
            $doc.mozFullScreenElement ||
            $doc.msFullscreenElement,
        );
      },
    );
    // browser polyfill
    var proto = Element.prototype;
    // requestFullScreen, exitFullScreen
    if (!proto.requestFullScreen) {
      ['webkit', 'moz', 'ms'].forEach(function (prefix) {
        // request
        var req =
            proto[prefix + 'RequestFullScreen'] || proto['msRequestFullscreen'],
          // exit (W3C Proposal)
          exit = $doc[prefix + 'CancelFullScreen'] || $doc['msExitFullscreen'];
        if (req) {
          proto.requestFullScreen = req;
          $doc.fullscreenEnabled = true;
        }
        exit && ($doc.exitFullScreen = exit);
      });
    }
    /**
     * ensures that the fullscreen element
     * is a singleton so that 2 elements are
     * not both in fullscreen at the same time
     *
     * doing this without an EventListener uses
     * less memory and is safer since we are not hijacking
     * the global window events
     *
     * @param {HTMLVideoElement} current
     */
    function ensure_fullscreen_singleton(current) {
      instances.forEach(function (video) {
        if (video.root === current || !video.in_fullscreen) return;
        video.emit(Events.FULLSCREEN_EXIT);
      });
    }
    $doc.on(Events.FULLSCREEN_CHANGE, function (e) {
      // https://github.com/flowplayer/flowplayer-native/issues/294
      // e.data is not the element in newer Firefox versions
      // so we should try the explicity value (e.data)
      // and fall back to the `e.target`
      var root = e.data || e.target;
      ensure_fullscreen_singleton(root);
    });
  })();
  function fullscreen(opts, root, video) {
    video.toggleFullScreen = function (flag) {
      // invert current state if no explicit state
      if (typeof flag != 'boolean') flag = !video.in_fullscreen;
      // no change
      if (flag == video.in_fullscreen) return;
      video.in_fullscreen = flag;
      video.emit(flag ? Events.FULLSCREEN_ENTER : Events.FULLSCREEN_EXIT);
      video.emit(Events.RESIZE);
      // enter native fullscreen
      if (mq.document.fullscreenEnabled && !opts.fake_fullscreen) {
        flag ? root.requestFullScreen() : mq.document.exitFullScreen();
      }
    };
    video.on([Events.FULLSCREEN_EXIT, Events.FULLSCREEN_ENTER], function (e) {
      var flag = e.type == Events.FULLSCREEN_ENTER;
      video.in_fullscreen = flag;
      root.toggleClass(states.FULLSCREEN, flag);
    });
    // doubleclick -> fullscreen
    if (opts.dblclickable !== false) {
      root.on(Events.DBL_CLICK, function (e) {
        e.target == root.ui && video.toggleFullScreen();
      });
    }
  }
  function fullscreen_button(config, video) {
    var $secondary = mq.div('fp-secondary').addClass('fp-togglable'),
      enter = view_box(ENTER_FULLSCREEN),
      exit = view_box(EXIT_FULLSCREEN);
    fullscreen(config, video.root, video);
    enter.on(Events.CLICK, video.toggleFullScreen);
    exit.on(Events.CLICK, video.toggleFullScreen);
    $secondary.append([enter, exit]);
    return $secondary;
  }
  function set_logo(container, logo, href) {
    if (!logo) return;
    container.empty();
    var contents = mq.img({
      class: 'fp-logo',
      src: logo,
    });
    if (href) {
      var link = mq.a({
        href: href,
      });
      link.append(contents);
      contents = link;
    }
    container.append(contents);
  }
  function set_duration(ele, duration) {
    if (!duration) return ele.empty();
    ele.txt(prettyTime(duration));
  }
  function header(config, ui, video) {
    var $header = mq.div('fp-header'),
      $primary = mq.div('fp-primary'),
      $duration = mq.div('fp-duration'),
      $fs = fullscreen_button(config, video);
    video.on(Events.CONFIG, function (e) {
      set_duration($duration, lens(e, 'data.duration'));
      set_logo($primary, lens(e, 'data.logo'), lens(e, 'data.logo_href'));
    });
    $header.append([$primary, $duration, $fs]);
    ui.append($header);
  }
  // the big play button
  function play(middle, video) {
    // proxy these events to the real video element
    // for a better API and to expose them to preventDefault()
    // https://github.com/flowplayer/flowplayer-native/issues/301
    middle.on([Events.CLICK, Events.DBL_CLICK], function (e) {
      // do not propogate this event
      e.preventDefault();
      // emit it on the real video object then
      video.emit(e.type, e.data);
      // also return false
      return false;
    });
    video.on(Events.CLICK, function (e) {
      setTimeout(function () {
        if (e.defaultPrevented) return; // noop
        video._play_toggled = true;
        video.togglePlay();
      }, 0);
    });
    video.on(Events.DBL_CLICK, function (e) {
      setTimeout(function () {
        if (e.defaultPrevented) return;
        video.toggleFullScreen();
      }, 0);
    });
  }
  var ICON_SETS = [1, 2, 3];
  function waiting_ele(middle) {
    var wait = mq.div('fp-wait');
    for (var i = 0; i < 4; i++) wait.append(mq('<b>'));
    return middle.append(wait);
  }
  function middle(opts, ui, video) {
    var $middle = mq.div('fp-middle');
    video.root.reaper.put('middle', $middle);
    play($middle, video);
    waiting_ele($middle);
    opts.mouseover_play &&
      video.root.on([Events.MOUSE_ENTER, Events.MOUSE_LEAVE], function (e) {
        video.togglePlay(e.type == 'mouseenter');
      });
    ICON_SETS.forEach(function (i) {
      $middle.append(
        mq
          .div(
            'fp-switch',
            [icons['PLAY_' + i], icons['PAUSE_' + i]].map(view_box),
          )
          .addClass('fp-play-' + i),
      );
    });
    ui.append($middle);
    return $middle;
  }
  var tick =
    typeof requestAnimationFrame === 'function'
      ? requestAnimationFrame
      : setTimeout;
  function throttle(callback, fps) {
    var frames_per_second = fps || 60,
      delay = Math.ceil(1000 / frames_per_second),
      last = 0,
      pending = null;
    return function __throttled() {
      var elapsed = Date.now() - last;
      if (pending !== null) return;
      pending = tick(function () {
        pending = null;
        callback.apply(this, arguments);
        last = Date.now();
      }, delay - elapsed);
    };
  }
  // alias common vars
  var div = mq.div;
  var span = mq.span;
  function link(reaper, name, rest, type) {
    if (typeof rest == 'function') {
      type = rest;
      rest = void 0;
    }
    rest = typeof rest == 'string' ? ' ' + rest : '';
    type = type || div;
    var base_name = fp(name);
    return reaper.put(name, type(base_name + rest));
  }
  function fp(rest) {
    return 'fp-' + rest;
  }
  function init_controls(container) {
    // create all UI elements
    var controls = div('fp-controls fp-togglable'),
      reaper = Reaper(controls),
      timeline = link(reaper, 'timeline', fp('bar')),
      btns = link(reaper, 'btns', fp('small-switch')),
      live = link(reaper, 'live-status').txt('live'),
      buffer = link(reaper, 'buffer'),
      progress = link(reaper, 'progress', fp('color')),
      hover = link(reaper, 'hover'),
      timestamp = link(reaper, 'timestamp'),
      duration = link(reaper, 'duration'),
      elapsed = link(reaper, 'elapsed', span).txt(prettyTime(0)),
      dragger = link(reaper, 'dragger', fp('color'));
    timeline.append([buffer, progress, hover, timestamp]);
    controls.append([btns, live, elapsed, timeline, duration]);
    Reaper(controls);
    btns.append([view_box(SMALL_PAUSE), view_box(SMALL_PLAY)]);
    progress.append(dragger);
    container.append(controls);
    return controls;
  }
  function tooltip_offset(tooltip, percent) {
    var offset =
      ((tooltip.innerWidth() / tooltip.parentElement.innerWidth()) * 100) / 2;
    tooltip.css('left', percent - offset + '%').show();
  }
  function buffer_update(_, video, controls) {
    if (isNaN(video.duration)) return;
    var buffered = video.buffered || {};
    if (!buffered.length) return;
    controls.buffer.css(
      'width',
      Math.min((buffered.end(0) / video.duration) * 100, 100) + '%',
    );
  }
  function progress(_, _video, _controls) {
    // reserved
  }
  function loadedmetadata(e, video, controls) {
    video.duration && controls.duration.txt(prettyTime(video.duration));
  }
  function timeupdate(e, video, controls) {
    controls.elapsed.txt(prettyTime(video.currentTime));
  }
  function timeline_repaint(e, video, controls) {
    controls.progress.css(
      'width',
      (video.currentTime / video.duration) * 100 + '%',
    );
  }
  function timeline_mouse_move(e, video, controls) {
    controls.hover.css('width', e.percent + '%');
  }
  function timeline_grab_start(e, video, controls) {
    controls.timestamp.show();
  }
  function timeline_grab_moved(e, video, controls) {
    controls.progress.css('width', e.percent + '%');
    video.currentTime = video.duration * (e.percent / 100);
  }
  function timeline_grab_end(_, _video, _controls) {
    // reserved
  }
  function recover() {
    // reserved
  }
  function timeline_mouse_enter(e, _video, controls) {
    controls.timestamp.show();
  }
  function timeline_mouse_leave(e, video, controls) {
    controls.hover.css('width', 0);
    controls.timestamp.hide();
  }
  function tooltip_update(e, video, controls) {
    var percent = e.percent,
      tooltip = controls.timestamp;
    if (!tooltip || isNaN(percent) || isNaN(video.duration)) return;
    tooltip_offset(controls.timestamp, percent);
    tooltip.txt(prettyTime((percent / 100) * video.duration));
  }
  var vod = Object.freeze({
    tooltip_offset: tooltip_offset,
    buffer_update: buffer_update,
    progress: progress,
    loadedmetadata: loadedmetadata,
    timeupdate: timeupdate,
    timeline_repaint: timeline_repaint,
    timeline_mouse_move: timeline_mouse_move,
    timeline_grab_start: timeline_grab_start,
    timeline_grab_moved: timeline_grab_moved,
    timeline_grab_end: timeline_grab_end,
    recover: recover,
    timeline_mouse_enter: timeline_mouse_enter,
    timeline_mouse_leave: timeline_mouse_leave,
    tooltip_update: tooltip_update,
  });
  /**
   * this controls snap back to live so that we seek to the closest
   * timestamp to live without triggering a rebuffer
   *
   * this is based on HLS.js internals
   *
   * TODO: make configurable
   */
  var REBUFFER_BUDGET = 10; // seconds
  function invert_percent(percent) {
    return 100 - percent;
  }
  function live_head(video) {
    try {
      return video.buffered.end(video.buffered.length - 1);
    } catch (err) {
      console.error(err);
      return video.duration;
    }
  }
  function is_dvr(video, dvr_threshold) {
    if (dvr_threshold == 0) return true;
    var buffered = video.buffered;
    var last_epoc = buffered.length - 1;
    if (last_epoc < 0) return false;
    try {
      return (
        buffered.end(last_epoc) - buffered.start(last_epoc) > dvr_threshold
      );
    } catch (err) {
      console.error(err);
      // when stalled this will throw
      return false;
    }
  }
  function live_tail(video) {
    try {
      return video.buffered.start(video.buffered.length - 1);
    } catch (err) {
      console.error(err);
      return 0;
    }
  }
  function seekable_range(video) {
    return {
      head: live_head(video) - REBUFFER_BUDGET,
      tail: live_tail(video),
    };
  }
  function live_waypoint(video) {
    try {
      // fetch the number of seconds that live started at
      // which is the offset for the number of seconds
      // we have been streaming when a livestream is not
      // in a seeked (backwards) state
      return video.currentTime - live_tail(video);
    } catch (err) {
      console.error(err);
      return video.currentTime;
    }
  }
  function seconds_in_past(video) {
    return (
      video.currentTime -
      (seconds_from_head(video, video.dvr_offset || 0) + REBUFFER_BUDGET)
    );
  }
  function time_watched(video) {
    var now = Date.now();
    return Math.round((now - (video.stream_start || now)) / 1000);
  }
  function seconds_from_head(video, percent) {
    var range = seekable_range(video),
      offset = (percent / 100) * range.head;
    return range.head - offset;
  }
  function progress$1(_, _video, _controls) {
    // reserved
  }
  function timeupdate$1(_, video, controls) {
    // we need to store a reference to the epoc time the stream started
    // in case of rebuffers and other network issues
    video.stream_start = video.stream_start || Date.now();
    if (video.currentTime <= 0) return;
    var timestamp =
      video.dvr_offset > 0
        ? '-' + prettyTime(seconds_from_head(video, video.dvr_offset))
        : prettyTime(time_watched(video));
    controls.duration.txt(timestamp);
  }
  function loadedmetadata$1(_, _video, _controls) {
    // reserved
  }
  function timeline_repaint$1(_, _video, _controls) {
    // reserved
  }
  function tooltip_update$1(e, video, controls) {
    var offset = seconds_from_head(video, e.percent);
    controls.timestamp.txt(prettyTime(offset));
    tooltip_offset(controls.timestamp, e.percent);
  }
  function seek_to_now(_, video, controls) {
    try {
      video.dvr_offset = 0;
      video.currentTime = live_head(video) - REBUFFER_BUDGET;
      video.root.removeClass(states.LIVE_SEEKED);
      controls.progress.css('width', 0);
    } catch (err) {
      // silence is golden
    }
  }
  function buffer_update$1(_, _video, _controls) {
    // reserved
  }
  function timeline_grab_start$1(_, _video, _controls) {
    // reserved
  }
  /**
   * on stream error, it is common to seek to the head of the
   * livestream, so we must reset the UI to reflect this
   */
  function recover$1(e, video, controls) {
    video.dvr_offset = 0;
    controls.progress.css('width', 0);
    video.root.removeClass(states.LIVE_SEEKED);
  }
  function timeline_grab_moved$1(e, video, controls) {
    video.dvr_offset = e.percent;
    var from_right = invert_percent(video.dvr_offset);
    controls.progress.css('width', from_right + '%');
    video.root.toggleClass(states.LIVE_SEEKED, from_right > 0);
    var seekable = seekable_range(video);
    video.currentTime = seekable.head * (video.dvr_offset / 100);
  }
  function timeline_grab_end$1(_, _video, _controls) {}
  function timeline_mouse_move$1(e, _video, controls) {
    controls.hover.css('width', invert_percent(e.percent) + '%');
  }
  function timeline_mouse_leave$1(_, _video, controls) {
    controls.hover.css('width', 0);
    controls.timestamp.hide();
  }
  var live = Object.freeze({
    invert_percent: invert_percent,
    live_head: live_head,
    is_dvr: is_dvr,
    live_tail: live_tail,
    seekable_range: seekable_range,
    live_waypoint: live_waypoint,
    seconds_in_past: seconds_in_past,
    time_watched: time_watched,
    seconds_from_head: seconds_from_head,
    progress: progress$1,
    timeupdate: timeupdate$1,
    loadedmetadata: loadedmetadata$1,
    timeline_repaint: timeline_repaint$1,
    tooltip_update: tooltip_update$1,
    seek_to_now: seek_to_now,
    buffer_update: buffer_update$1,
    timeline_grab_start: timeline_grab_start$1,
    recover: recover$1,
    timeline_grab_moved: timeline_grab_moved$1,
    timeline_grab_end: timeline_grab_end$1,
    timeline_mouse_move: timeline_mouse_move$1,
    timeline_mouse_leave: timeline_mouse_leave$1,
  });
  var kinds = {
    vod: vod,
    live: live,
  };
  function Behavior(args) {
    if (!(this instanceof Behavior)) return new Behavior(args);
    this.route = function (kind, e) {
      var router = kinds[kind] || {};
      var callback = router[e.type];
      if (callback) return callback.apply(e.currentTarget, [e].concat(args));
      throw new Error(
        'could not handle routed event of type (' + kind + ':' + e.type + ')',
      );
    };
  }
  // the icon toggle class prefix
  var icon_set = 'use-play-';
  /**
   * extension to inject the control bar into the player
   *
   * @param      {Object}  opts    The options
   * @param      {DOM}     root    The root element
   * @return     {void}
   */
  function controls(opts, root, video) {
    // short-circuit when controls are not desired
    if (!opts.controls) return;
    // set the icon set to use
    if (!~root.className.indexOf(icon_set))
      root.addClass(icon_set + (opts.play || 1));
    var controls = init_controls(root.ui);
    root.reaper.put('timeline', controls.timeline);
    root.reaper.put('controls', controls);
    var behavior = Behavior([video, controls]);
    // common behaviors
    controls.btns.on(Events.CLICK, video.togglePlay);
    controls['live-status'].on(Events.CLICK, function () {
      behavior.route('live', {
        type: 'seek_to_now',
      });
    });
    video.on(Events.CONFIG, function (e) {
      var secs = lens(e, 'data.duration');
      if (isNaN(secs)) return;
      controls.duration.txt(prettyTime(secs));
    });
    var repaint_timeline = throttle(function () {
      if (video.reaper == 0) return;
      var timeline = controls.timeline;
      behavior.route(kind_of_behavior(opts), {
        type: 'timeline_repaint',
      });
      // don't repaint if video is paused or seeking
      if (video.paused || (timeline && timeline.grabbing)) return;
      requestAnimationFrame(repaint_timeline);
    }, 60);
    video.on(Events.PLAYING, repaint_timeline);
    if (!video.paused) repaint_timeline(video, controls.timeline);
    // playback progress
    video.on(Events.TIME_UPDATE, function (e) {
      if (video.reaper == 0) return;
      var kind = kind_of_behavior(opts);
      behavior.route(kind, e);
      behavior.route(kind, {
        type: 'buffer_update',
      });
    });
    // buffer
    video.on(Events.PROGRESS, function (e) {
      if (video.reaper == 0) return;
      var kind = kind_of_behavior(opts);
      if (opts.live && !opts.dvr && is_dvr(video, opts.seconds_to_dvr || 60)) {
        video.setOpts({
          dvr: true,
        });
      }
      behavior.route(kind, e);
      behavior.route(kind, {
        type: 'buffer_update',
      });
    });
    function is_live(video) {
      return typeof video.opts.live === 'undefined'
        ? video.duration === Infinity
        : video.opts.live;
    }
    // progressbar
    video.on(Events.METADATA, function (e) {
      video.stream_start ||
        video.setOpts({
          live: is_live(video),
        });
      var kind = kind_of_behavior(opts);
      behavior.route(kind, e);
      behavior.route(kind, {
        type: 'buffer_update',
      });
    });
    video.on(Events.DURATION_CHANGE, function () {
      video.setOpts({
        live: is_live(video),
        duration: video.duration,
      });
    });
    video.on(Events.RECOVER, function (e) {
      var kind = kind_of_behavior(opts);
      behavior.route(kind, e);
    });
    slide(controls.timeline, {
      onseek: ensure_valid_video(video, function (percent) {
        var kind = kind_of_behavior(opts);
        behavior.route(kind, {
          type: 'timeline_grab_moved',
          percent: percent,
        });
        behavior.route(kind, {
          type: 'tooltip_update',
          percent: percent,
        });
      }),
      onstart: ensure_valid_video(video, function () {
        root.addClass(states.SEEKING);
        behavior.route(kind_of_behavior(opts), {
          type: 'timeline_grab_start',
        });
      }),
      onend: function () {
        // github:issue/349
        // we must restart the timeline repaint loop
        // even if the video is disabled
        if (video.disabled) return repaint_timeline();
        root.removeClass(states.SEEKING);
        behavior.route(kind_of_behavior(opts), {
          type: 'timeline_grab_end',
        });
        repaint_timeline();
      },
      onmouse: ensure_valid_video(video, function (percent) {
        if (controls.timeline.grabbing) return;
        var kind = kind_of_behavior(opts);
        behavior.route(kind, {
          type: 'timeline_mouse_move',
          percent: percent,
        });
        behavior.route(kind, {
          type: 'tooltip_update',
          percent: percent,
        });
      }),
    }).on(Events.MOUSE_LEAVE, function () {
      behavior.route(kind_of_behavior(opts), {
        type: 'timeline_mouse_leave',
      });
    });
  }
  function kind_of_behavior(opts) {
    return opts.live ? 'live' : 'vod';
  }
  function ensure_valid_video(video, fn) {
    return function _validator() {
      if (isNaN(video.duration) || video.disabled) return;
      else fn.apply(null, arguments);
    };
  }
  function printError(ele, msg, details) {
    if (!ele) return;
    var err = mq.div('fp-error').txt(msg);
    ele.append(err);
    if (details) {
      err.append(mq.div('fp-error-details').txt(details));
    }
  }
  function error_message(opts, root, video) {
    // error
    video.on(Events.ERROR, function (evt) {
      var e = evt.data || {},
        $toggle = video.togglePlay,
        code = evt.code || e.code;
      console.error(e);
      // do not break the UI for this
      if (e.name == 'AbortError') return;
      root.addClass(states.ERRORED);
      if (code != 8) {
        video.togglePlay = noop;
        video.one(Events.RECOVER, function () {
          video.togglePlay = $toggle;
          video.removeClass(states.ERRORED);
        });
      }
      if ((navigator || {}).onLine === false) {
        e.code = 2;
        e.message = 'Not connected to internet';
      }
      var msg = e.message || e.stack || 'an error occurred';
      return printError(root.ui, msg, e.details);
    });
  }
  function title_and_desc(config, root, video) {
    var container = root.append(
      mq.div({
        class: 'fp-footer',
      }),
    );
    video.on(Events.CONFIG, function (e) {
      var data = e.data,
        desc = data.description,
        title = data.title;
      container.empty();
      if (typeof title == 'string') {
        container.append(
          mq
            .div({
              class: 'fp-title',
            })
            .txt(data.title),
        );
      }
      if (typeof desc == 'string') {
        container.append(
          mq
            .div({
              class: 'fp-desc',
            })
            .txt(data.description),
        );
      }
    });
  }
  function ui(config, root, video) {
    var frag = document.createDocumentFragment(),
      ui = mq.div('fp-ui');
    frag.appendChild(ui);
    root.reaper.put('ui', ui);
    title_and_desc(config, root, video);
    header(config, ui, video);
    middle(config, ui, video);
    controls(config, root, video);
    volume(config, root.controls, video);
    error_message(config, root, video);
    root.appendChild(frag);
    root.on([Events.MOUSE_ENTER, Events.MOUSE_LEAVE], function (e) {
      root.toggleClass('is-hovered', e.type == Events.MOUSE_ENTER);
    });
    // https://github.com/flowplayer/flowplayer-native/issues/297
    var move_timeout = false;
    ui.on(Events.MOUSE_MOVE, function () {
      if (typeof move_timeout == 'number') clearTimeout(move_timeout);
      root.addClass('is-hovered');
      move_timeout =
        video.paused == false &&
        setTimeout(function () {
          root.removeClass('is-hovered');
        }, 2000);
    });
  }
  var LEVEL = {
    0: 'is-loading-0',
    1: 'is-loading-1',
    2: 'is-loading-2',
    3: 'is-loading-3',
  };
  function transition(root, level, cb) {
    setTimeout(function () {
      root.addClass(LEVEL[level]);
      var i = level;
      while (i < 4) {
        root.removeClass(LEVEL[i]);
        ++i;
      }
      cb && cb();
    }, 400 - level * 66);
  }
  function blur_in(opt, root, video) {
    if (opt.animation == false) return;
    if (opt.preload == 'none') return;
    root.addClass(LEVEL[3]);
    video.on(Events.LOAD_START, function () {
      transition(root, 2);
    });
    video.on(Events.METADATA, function () {
      transition(root, 1);
    });
    video.on(Events.CAN_PLAY, function () {
      transition(root, 0);
    });
  }
  function metering(config, root, video) {
    if (ACL.from_token(config.token).is_granted(ACL.permissions.NO_METERING))
      return;
    var token_id = Token.id(config.token);
    if (!token_id) return;
    var meter_response = function (xhr) {
      if (xhr.status === 403)
        video.emit(Events.NON_RECOVERABLE_ERROR, {
          reason: 'token',
          details: 'The token online validation failed',
        });
    };
    var tick = meter.bind(null, token_id, meter_response);
    video.one(Events.PLAYING, tick);
  }
  function meter(token_id, cb) {
    var data = {
      token_id: token_id,
      factor: 1,
      rnd: Math.random().toString(36).substring(2),
    };
    var xhr = new XMLHttpRequest(),
      body = JSON.stringify(data);
    xhr.timeout = 2500;
    xhr.open(
      'POST',
      flowplayer.METERING_URL || 'https://pmi.flowplayer.com/in',
      true,
    );
    xhr.send(body);
    xhr.addEventListener('load', cb.bind(null, xhr));
  }
  available(function () {
    from_string(
      "<svg id='fp-icons' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'><defs><path id='FS' d='M1 9V1h12'/><path id='fp-play-button' d='M19.201 4.78l18.546 30.001a2.001 2.001 0 0 1-1.707 3.052H-1.046a2 2 0 0 1-1.701-3.052l18.545-30a2 2 0 0 1 3.403 0' transform='rotate(90 20 25.4)'/><g id='fp-pause-lines'><rect class='fp-rect' x='8.5' y='5' width='11' height='36'/><rect class='fp-rect' x='26.5' y='5' width='11' height='36'/></g></defs><g id='fp-play' class='fp-fill'><use xlink:href='#fp-play-button'></use></g><g id='fp-play-circle' class='fp-fill'><circle cx='22.9' cy='22.9' r='23.5' class='fp-thin-stroke' fill='none'/><use xlink:href='#fp-play-button' transform='translate(11.5, 9.8) scale(.57)'></use></g><g id='fp-play-stroke' fill='none' class='fp-thin-stroke'><use xlink:href='#fp-play-button'></use></g><g id='fp-pause' class='fp-fill'><use xlink:href='#fp-pause-lines'></use></g><g id='fp-pause-stroke' fill='none' class='fp-thin-stroke'><use xlink:href='#fp-pause-lines'></use></g><g id='fp-volume' class='fp-fill'><path class='fp-rect' d='M0 15h30v24H0z'/><path d='M1 27L31 0v54z'/></g><g id='fp-fs' fill='none' class='fp-thin-stroke'><use xlink:href='#FS'/><use xlink:href='#FS' transform='matrix(1 0 0 -1 0 26)'/><use xlink:href='#FS' transform='matrix(-1 0 0 1 36 0)'/><use xlink:href='#FS' transform='rotate(180 18 13)'/></g><g id='fp-exit' fill='none' class='fp-thin-stroke'><use xlink:href='#FS' transform='translate(22 17)'/><use xlink:href='#FS' transform='matrix(-1 0 0 1 13 17)'/><use xlink:href='#FS' transform='rotate(180 6.5 4.5)'/><use xlink:href='#FS' transform='matrix(1 0 0 -1 22 9)'/></g></svg>",
    );
  });
  flowplayer$1(analytics, ui, blur_in, mobile, metering);
  flowplayer$1.volume = volume;
  flowplayer$1.storage = storage;
  return flowplayer$1;
});
